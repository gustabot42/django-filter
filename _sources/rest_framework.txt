Django Rest Framework Integration
=================================

The `DjangoFilterBackend` class supports highly customizable field filtering, using the [django-filter package][django-filter].

To use REST framework's `DjangoFilterBackend`, first install `django-filter`.

.. code-block:: bash

    pip install django-filter

If you are using the browsable API or admin API you may also want to install `django-crispy-forms`, which will enhance the presentation of the filter forms in HTML views, by allowing them to render Bootstrap 3 HTML.

.. code-block:: bash

    pip install django-crispy-forms

With crispy forms installed and added to Django's `INSTALLED_APPS`, the browsable API will present a filtering control for `DjangoFilterBackend`, like so:

.. image:: img/form.png

#### Specifying filter fields

If all you need is simple equality-based filtering, you can set a `filter_fields` attribute on the view, or viewset, listing the set of fields you wish to filter against.

.. code-block:: python

    class ProductList(generics.ListAPIView):
        queryset = Product.objects.all()
        serializer_class = ProductSerializer
        filter_backends = (filters.DjangoFilterBackend,)
        filter_fields = ('category', 'in_stock')

This will automatically create a `FilterSet` class for the given fields, and will allow you to make requests such as:

    http://example.com/api/products?category=clothing&in_stock=True

#### Specifying a FilterSet

For more advanced filtering requirements you can specify a `FilterSet` class that should be used by the view.  For example:

.. code-block:: python

    import django_filters
    from myapp.models import Product
    from myapp.serializers import ProductSerializer
    from rest_framework import filters
    from rest_framework import generics

    class ProductFilter(filters.FilterSet):
        min_price = django_filters.NumberFilter(name="price", lookup_expr='gte')
        max_price = django_filters.NumberFilter(name="price", lookup_expr='lte')
        class Meta:
            model = Product
            fields = ['category', 'in_stock', 'min_price', 'max_price']

    class ProductList(generics.ListAPIView):
        queryset = Product.objects.all()
        serializer_class = ProductSerializer
        filter_backends = (filters.DjangoFilterBackend,)
        filter_class = ProductFilter


Which will allow you to make requests such as:

    http://example.com/api/products?category=clothing&max_price=10.00

You can also span relationships using `django-filter`, let's assume that each
product has foreign key to `Manufacturer` model, so we create filter that
filters using `Manufacturer` name. For example:

.. code-block:: python

    from myapp.models import Product
    from myapp.serializers import ProductSerializer
    from rest_framework import filters
    from rest_framework import generics

    class ProductFilter(filters.FilterSet):
        class Meta:
            model = Product
            fields = ['category', 'in_stock', 'manufacturer__name']

This enables us to make queries like:

    http://example.com/api/products?manufacturer__name=foo

This is nice, but it exposes the Django's double underscore convention as part of the API.  If you instead want to explicitly name the filter argument you can instead explicitly include it on the `FilterSet` class:

.. code-block:: python

    import django_filters
    from myapp.models import Product
    from myapp.serializers import ProductSerializer
    from rest_framework import filters
    from rest_framework import generics

    class ProductFilter(filters.FilterSet):
        manufacturer = django_filters.CharFilter(name="manufacturer__name")

        class Meta:
            model = Product
            fields = ['category', 'in_stock', 'manufacturer']

And now you can execute:

    http://example.com/api/products?manufacturer=foo

For more details on using filter sets see the [django-filter documentation][django-filter-docs].

---

**Hints & Tips**

* By default filtering is not enabled.  If you want to use `DjangoFilterBackend` remember to make sure it is installed by using the `'DEFAULT_FILTER_BACKENDS'` setting.
* When using boolean fields, you should use the values `True` and `False` in the URL query parameters, rather than `0`, `1`, `true` or `false`.  (The allowed boolean values are currently hardwired in Django's [NullBooleanSelect implementation][nullbooleanselect].)
* `django-filter` supports filtering across relationships, using Django's double-underscore syntax.

---
